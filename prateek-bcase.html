<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tidal Energy Plant - Globalia Smart City</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body {
            font-family: Georgia, serif;
        }

        /* Style for the accordion button */
        .accordion {
            background-color: #4CAF50;
            color: white;
            padding: 10px;
            width: 100%;
            text-align: left;
            border: none;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
        }

        .accordion:hover {
            background-color: #45a049;
        }

        /* Style for the dropdown content */
        .panel {
            padding: 0 18px;
            display: none;
            background-color: #f1f1f1;
            overflow: hidden;
            margin-bottom: 10px;
        }

        /* Add some padding to the panel content */
        .panel p {
            padding: 10px;
        }

        /* Style for code */
        pre {
            background-color: #2d2d2d;
            color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

    </style>
</head>
<body>
    <header>
        <h1>Tidal Energy Plant for Smart City Development in Globalia</h1>
    </header>

    <div class="container">
        <!-- Introduction Section -->
        <section>
            <h2>Introduction</h2>
            <p>Globalia, a smart city near Goa covering 1500 square feet, is intended to be a model for sustainable urban development. With a focus on renewable energy and advanced technologies, Globalia aims to integrate green infrastructure and optimize resources to achieve energy efficiency. At the heart of this vision is a tidal energy plant, which utilizes the predictable power of tides to generate electricity. By leveraging algorithms to optimize location selection, energy distribution, and grid management, Globalia ensures sustainable growth and reduced environmental impact.</p>
        </section>

        <!-- Why Tidal Energy Section -->
        <section>
            <h2>Why Tidal Energy for Globalia?</h2>
            <ul>
                <li><strong>Predictability:</strong> Unlike solar and wind, tidal cycles are regular and dependable.</li>
                <li><strong>Efficiency:</strong> The high density of water enables efficient energy generation even with smaller turbines.</li>
                <li><strong>Environmental Compatibility:</strong> Tidal energy has minimal visual impact and contributes to zero-emission power production.</li>
            </ul>
            <p>For Globalia, tidal energy is a logical choice due to its proximity to the coast and the presence of estuaries, making it ideal for implementing tidal barrage technology.</p>
        </section>

        <!-- SDG Alignment Section -->
        <section>
            <h2>Alignment with Sustainable Development Goals (SDG)</h2>
            <h3>Target 11.6:</h3>
            <p>Reduce the adverse environmental impact of cities by 2030.</p>
            <ul>
                <li><strong>Indicator:</strong> Reduction in carbon emissions through tidal energy adoption.</li>
                <li><strong>Metric:</strong> Energy generated per kilowatt-hour (kWh) with zero emissions.</li>
            </ul>
            <h3>Target 11.3:</h3>
            <p>Enhance sustainable urbanization through participatory urban planning.</p>
            <ul>
                <li><strong>Indicator:</strong> Proportion of cities with integrated energy planning.</li>
                <li><strong>Metric:</strong> Energy coverage ratio across urban demand centers.</li>
            </ul>
        </section>

        <!-- Advantages Section -->
        <section>
            <h2>Advantages of Tidal Energy</h2>
            <ul>
                <li><strong>Reliable Energy Source:</strong> Tidal cycles are predictable and unaffected by weather changes.</li>
                <li><strong>Sustainability:</strong> Zero carbon emissions during operation.</li>
                <li><strong>High Energy Density:</strong> Water’s density enables significant power generation with smaller infrastructure.</li>
                <li><strong>Longevity:</strong> Infrastructure has a lifespan of several decades with proper maintenance.</li>
                <li><strong>Integration with Smart Grids:</strong> Algorithms ensure optimized energy distribution with minimal loss.</li>
            </ul>
        </section>

        <!-- Challenges and Solutions Section -->
        <section>
            <h2>Challenges and Solutions</h2>
            <h3>Challenges:</h3>
            <ul>
                <li><strong>High Initial Costs:</strong> Construction and deployment require significant investment.</li>
                <li><strong>Environmental Impact:</strong> Marine ecosystems may be disrupted during construction and operation.</li>
                <li><strong>Operational Maintenance:</strong> Challenges like corrosion and biofouling increase maintenance efforts.</li>
            </ul>
            <h3>Solutions:</h3>
            <ul>
                <li><strong>Cost Management:</strong> Government funding and technological advancements can reduce costs.</li>
                <li><strong>Eco-Friendly Designs:</strong> Fish-friendly turbines and lagoon-style tidal plants minimize marine disruption.</li>
                <li><strong>Advanced Materials:</strong> Corrosion-resistant alloys and coatings reduce maintenance challenges.</li>
            </ul>
        </section>

        <!-- Implementation Stage Section -->
        <section>
            <h2>Implementation Stage</h2>

            <h3>Phase 1: Location Selection</h3>
            <p>Using Merge Sort, potential sites are ranked based on tidal range, proximity to Globalia, and cost, with a weighted scoring system.</p>
            <p><strong>Example:</strong> Ranked Sites: Site B > Site A > Site C</p>
            <div class="button-container">
                <a href="Portfolio_location.cpp" class="button">View Location Selection Code</a>
            </div>
            
            <!-- Algorithm Analysis for Merge Sort -->
            <button class="accordion">Algorithm Analysis - Merge Sort</button>
            <div class="panel">
                <p><strong>Time Complexity:</strong> O(n log n)</p>
                <p><strong>Computational Thinking Breakdown:</strong></p>
                <ul>
                    <li><strong>Decomposition (Sliding Window):</strong> Divide the problem into smaller parts, focusing on smaller windows of data at a time. In this case, Merge sort processes subsets of sites and recursively merges them into a sorted order.</li>
                    <li><strong>Pattern Recognition (Lazy Propagation):</strong> Postpone operations until necessary to improve efficiency. Scores are calculated only when needed for ranking, avoiding unnecessary computations.</li>
                    <li><strong>Abstraction (Prefix and Suffix):</strong> Extract the essence by splitting the array into parts and merging them back. Merge sort divides the list into prefixes and suffixes, then merges them after sorting.</li>
                </ul>
                <p><strong>Design Techniques:</strong></p>
                <ul>
                    <li><strong>Hierarchical Data:</strong> Organize data hierarchically to solve subproblems. Merge sort builds a hierarchy of divisions and recombinations to sort the sites.</li>
                    <li><strong>Greedy Scoring:</strong> Choose the optimal edge in every step. Scores are calculated greedily based on weighted factors, ranking sites to identify the best one.</li>
                    <li><strong>Pre-Computing (Parental Dominance):</strong> Leverage pre-computed results for decision-making. Pre-computed scores simplify the sorting process, prioritizing high-scoring sites.</li>
                </ul>
                <p><strong>Principles:</strong></p>
                <ul>
                    <li><strong>Brave and Cautious Travel:</strong> Explore data breadth-wise and dive into subsets. Merge sort explores and merges subsets of scores and names cautiously to ensure order.</li>
                    <li><strong>Score Calculation (Balancing a Tree):</strong> Compute a weighted score for each site to balance competing factors. Scores balance tidal range, distance, and cost to ensure a fair evaluation.</li>
                    <li><strong>Recursive Merging (Kleene Closure):</strong> Apply transitive properties by merging smaller subsets. Merge sort recursively builds sorted lists by ensuring each merge respects the sorted order.</li>
                </ul>
            </div>

            <h3>Phase 2: Energy Demand Sorting</h3>
            <p>Quick Sort arranges sector-wise energy demands in ascending order for efficient allocation.</p>
            <p><strong>Example:</strong> Sorted Demands: Sector B (120 kWh), Sector A (150 kWh), Sector C (200 kWh)</p>
            <div class="button-container">
                <a href="Portfolio_quick.cpp" class="button">View Quick Sort Code</a>
            </div>
            
            <!-- Algorithm Analysis for Quick Sort -->
            <button class="accordion">Algorithm Analysis - Quick Sort</button>
            <div class="panel">
                <p><strong>Time Complexity:</strong> O(n log n) on average, but in the worst case, it can be O(n^2). This occurs when the pivot selected is always the smallest or largest element, leading to unbalanced partitions.</p>
                <p><strong>Computational Thinking Breakdown:</strong></p>
                <ul>
                    <li><strong>Decomposition:</strong> Divide the problem into smaller manageable parts. QuickSort recursively divides the array into smaller subarrays, sorting each smaller part separately.</li>
                    <li><strong>Pattern Recognition:</strong> Identify common recurring patterns. The partitioning process is repeated in each recursive call, identifying the pivot and organizing the data around it.</li>
                    <li><strong>Abstraction:</strong> Keep only the required data for the task. QuickSort focuses on sorting the energy demand values and ignores unnecessary details like the initial positions of elements once they have been rearranged.</li>
                </ul>
                <p><strong>Design Techniques:</strong></p>
                <ul>
                    <li><strong>Divide and Conquer:</strong> Divide the problem into smaller parts and then solve the problem. QuickSort divides the array into two smaller subarrays (left and right of the pivot) and recursively sorts them.</li>
                    <li><strong>Greedy Technique:</strong> Select the optimal choice in each iteration. QuickSort uses the pivot element as the "optimal" choice to partition the array in each step.</li>
                    <li><strong>Space and Time Tradeoff:</strong> If you optimize time, you lose space. QuickSort’s in-place partitioning reduces the space complexity, but the recursion depth could lead to higher space usage in the call stack.</li>
                </ul>
                <p><strong>Principles:</strong></p>
                <ul>
                    <li><strong>Partitioning:</strong> Divide the array into two subarrays around the pivot. The algorithm selects a pivot element and reorders the array such that elements less than the pivot are on one side and elements greater than the pivot are on the other side.</li>
                    <li><strong>Recursive Approach:</strong> Apply the same process repeatedly to the smaller subarrays. QuickSort recursively calls itself on the left and right partitions until the entire array is sorted.</li>
                </ul>
            </div>

            <h3>Phase 3: Optimized Energy Grid Management</h3>
            <p>Dijkstra’s Algorithm calculates shortest paths for energy transmission, minimizing losses.</p>
            <div class="button-container">
                <a href="Portfolio_energydist.cpp" class="button">View Dijkstra's Algorithm Code</a>
            </div>
            
            <!-- Algorithm Analysis for Dijkstra's Algorithm -->
            <button class="accordion">Algorithm Analysis - Dijkstra's Algorithm</button>
            <div class="panel">
                <p><strong>Time Complexity:</strong> O(V^2): For each of the V vertices, the algorithm performs a linear search to find the minimum distance vertex and checks all other vertices to relax edges.</p>
                <p><strong>Computational Thinking Breakdown:</strong></p>
                <ul>
                    <li><strong>Decomposition:</strong> Divide the problem into smaller manageable parts. Dijkstra's algorithm breaks down the problem of finding the shortest path into smaller subproblems by calculating the shortest path from each vertex to all others iteratively.</li>
                    <li><strong>Pattern Recognition:</strong> Identify common recurring patterns. The algorithm repeatedly finds the minimum tentative distance to an unvisited vertex in each iteration. This pattern is recognized and applied in every step to reduce the problem size.</li>
                    <li><strong>Abstraction:</strong> Keep only the required data for the task. Dijkstra’s algorithm focuses on key data: the shortest distances (dist[]) and the paths (path[]). It ignores unnecessary details like the full graph structure after reading the cost matrix.</li>
                </ul>
                <p><strong>Design Techniques:</strong></p>
                <ul>
                    <li><strong>Greedy Technique:</strong> Select the optimal choice in each iteration. Dijkstra’s algorithm uses the greedy approach by always choosing the vertex with the smallest tentative distance in each iteration, aiming for the optimal solution.</li>
                    <li><strong>Space and Time Tradeoff:</strong> If you optimize time, you lose space. Dijkstra uses a priority queue (min-heap) to efficiently find the vertex with the smallest distance, which saves time but uses additional space for the queue.</li>
                </ul>
                <p><strong>Principles:</strong></p>
                <ul>
                    <li><strong>Edge Relaxation:</strong> Select the minimum edge and make it part of the solution set. This is the core of Dijkstra’s algorithm, where each edge is relaxed by updating the shortest path to the neighboring vertices.</li>
                </ul>
            </div>

        </section>
    </div>

    <footer>
        <p>&copy; 2024 Globalia Smart City Project. All rights reserved.</p>
    </footer>

    <script>
        var acc = document.getElementsByClassName("accordion");
        var i;

        for (i = 0; i < acc.length; i++) {
            acc[i].addEventListener("click", function() {
                this.classList.toggle("active");
                var panel = this.nextElementSibling;
                if (panel.style.display === "block") {
                    panel.style.display = "none";
                } else {
                    panel.style.display = "block";
                }
            });
        }
    </script>
</body>
</html>
