<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tidal Energy Plant - Globalia Smart City</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>Tidal Energy Plant for Smart City Development in Globalia</h1>
    </header>

    <div class="container">
        <!-- Implementation Stage Section -->
        <section>
            <h2>Implementation Stage</h2>

            <h3>Phase 1: Location Selection</h3>
            <p>Using Merge Sort, potential sites are ranked based on tidal range, proximity to Globalia, and cost, with a weighted scoring system.</p>
            <p><strong>Example:</strong> Ranked Sites: Site B > Site A > Site C</p>
            <div class="button-container">
                <a href="Portfolio_location.cpp" class="button">View Location Selection Code</a>
            </div>
            
            <!-- Algorithm Analysis and Code for Merge Sort -->
            <button class="accordion">Algorithm Analysis - Merge Sort</button>
            <div class="panel">
                <p><strong>Time Complexity:</strong> O(n log n)</p>
                <p><strong>Computational Thinking:</strong></p>
                <ul>
                    <li><strong>Decomposition:</strong> Divide the problem into smaller parts, focusing on smaller windows of data at a time.</li>
                    <li><strong>Pattern Recognition:</strong> Postpone operations until necessary to improve efficiency.</li>
                    <li><strong>Abstraction:</strong> Extract the essence by splitting the array into parts and merging them back.</li>
                </ul>
                <p><strong>Design Techniques:</strong></p>
                <ul>
                    <li><strong>Hierarchical Data:</strong> Organize data hierarchically to solve subproblems.</li>
                    <li><strong>Greedy Scoring:</strong> Choose the optimal edge in every step.</li>
                </ul>
                <p><strong>Principles:</strong></p>
                <ul>
                    <li><strong>Brave and Cautious Travel:</strong> Explore data breadth-wise and dive into subsets.</li>
                    <li><strong>Score Calculation:</strong> Compute a weighted score for each site to balance competing factors.</li>
                </ul>
            </div>

            <!-- Code for Merge Sort -->
            <button class="accordion">View Merge Sort Code</button>
            <div class="panel">
                <pre><code>#include &lt;iostream&gt;
using namespace std;

void merge(float scores[], string names[], int left, int mid, int right)
{
    int i = left, j = mid + 1, k = 0;
    float temp_scores[right - left + 1];
    string temp_names[right - left + 1];

    while (i &lt;= mid && j &lt;= right)
    {
        if (scores[i] &gt;= scores[j])
        {
            temp_scores[k] = scores[i];
            temp_names[k] = names[i];
            i++;
        }
        else
        {
            temp_scores[k] = scores[j];
            temp_names[k] = names[j];
            j++;
        }
        k++;
    }

    while (i &lt;= mid)
    {
        temp_scores[k] = scores[i];
        temp_names[k] = names[i];
        i++;
        k++;
    }

    while (j &lt;= right)
    {
        temp_scores[k] = scores[j];
        temp_names[k] = names[j];
        j++;
        k++;
    }

    for (int x = 0; x &lt; k; x++)
    {
        scores[left + x] = temp_scores[x];
        names[left + x] = temp_names[x];
    }
}

void merge_sort(float scores[], string names[], int left, int right)
{
    if (left &lt; right)
    {
        int mid = (left + right) / 2;
        merge_sort(scores, names, left, mid);
        merge_sort(scores, names, mid + 1, right);
        merge(scores, names, left, mid, right);
    }
}

void calculate_scores(float tidal_range[], float distance[], float cost[], float scores[], int count)
{
    for (int i = 0; i &lt; count; i++)
    {
        scores[i] = (tidal_range[i] * 0.5) + (distance[i] * 0.3) + (cost[i] * 0.2);
    }
}

int main()
{
    int site_count;
    cout &lt;&lt; "Enter the number of sites: ";
    cin &gt;&gt; site_count;

    string site_names[site_count];
    float tidal_range[site_count], distance[site_count], cost[site_count], scores[site_count];

    for (int i = 0; i &lt; site_count; i++)
    {
        cout &lt;&lt; "Enter details for site " &lt;&lt; i + 1 &lt;&lt; "(Name,Tidal Range,Distance,Cost): ";
        cin &gt;&gt; site_names[i] &gt;&gt; tidal_range[i] &gt;&gt; distance[i] &gt;&gt; cost[i];
    }

    calculate_scores(tidal_range, distance, cost, scores, site_count);
    merge_sort(scores, site_names, 0, site_count - 1);

    cout &lt;&lt; "\nRanked Sites Based on Scores:\n";
    for (int i = 0; i &lt; site_count; i++)
    {
        cout &lt;&lt; site_names[i] &lt;&lt; ": Tidal Range = " &lt;&lt; tidal_range[i]<< "m, Distance = " &lt;&lt; distance[i] << "km, Cost = Rs."
        &lt;&lt; cost[i]<< "M, Score = " &lt;&lt; scores[i] << endl;
    }

    return 0;
}
                </code></pre>
            </div>

            <!-- Algorithm Analysis and Code for Quick Sort -->
            <button class="accordion">Algorithm Analysis - Quick Sort</button>
            <div class="panel">
                <p><strong>Time Complexity:</strong> O(n log n) on average, O(n^2) in the worst case.</p>
                <p><strong>Computational Thinking:</strong></p>
                <ul>
                    <li><strong>Decomposition:</strong> The problem is divided into smaller subproblems, sorting each section recursively.</li>
                    <li><strong>Pattern Recognition:</strong> Recognizing the recursive pattern of partitioning the array and sorting the two subarrays.</li>
                    <li><strong>Abstraction:</strong> Focusing only on the values to be sorted, ignoring the original indices once rearranged.</li>
                </ul>
                <p><strong>Design Techniques:</strong></p>
                <ul>
                    <li><strong>Divide and Conquer:</strong> The array is recursively divided into smaller subarrays.</li>
                    <li><strong>Greedy Technique:</strong> The pivot is selected as the "optimal" element in each iteration to divide the array.</li>
                </ul>
                <p><strong>Principles:</strong></p>
                <ul>
                    <li><strong>Partitioning:</strong> Elements are divided based on comparison to the pivot.</li>
                    <li><strong>Recursive Approach:</strong> The algorithm applies partitioning recursively until all subarrays are sorted.</li>
                </ul>
            </div>

            <!-- Code for Quick Sort -->
            <button class="accordion">View Quick Sort Code</button>
            <div class="panel">
                <pre><code>#include&lt;iostream&gt;
using namespace std;

#define MAX 100

int partition(int A[MAX], int l, int r)
{
    int p = A[l];
    int i = l;
    int j = r + 1;

    do
    {
        do
        {
            i++;
        } while (i &lt;= r && A[i] &lt; p);

        do
        {
            j--;
        } while (A[j] &gt; p);

        if (i &lt; j)
            swap(A[i], A[j]);
    } while (i &lt; j);

    swap(A[l], A[j]);

    return j;
}

void quicksort(int A[MAX], int l, int r)
{
    if (l &lt; r)
    {
        int s = partition(A, l, r);
        quicksort(A, l, s - 1);
        quicksort(A, s + 1, r);
    }
}

int main()
{
    int n, A[MAX];
    cout &lt;&lt; "Enter the number of sectors: ";
    cin &gt;&gt; n;
    cout &lt;&lt; "Enter the energy demand for each sector (in kWh): " &lt;&lt; endl;

    for (int i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; A[i];
    }

    quicksort(A, 0, n - 1);

    cout &lt;&lt; "Sorted energy demands (from low to high): ";
    for (int i = 0; i &lt; n; i++)
    {
        cout &lt;&lt; A[i] &lt;&lt; " ";
    }

    return 0;
}
                </code></pre>
            </div>

            <!-- Algorithm Analysis and Code for Dijkstra's Algorithm -->
            <button class="accordion">Algorithm Analysis - Dijkstra's Algorithm</button>
            <div class="panel">
                <p><strong>Time Complexity:</strong> O(V^2), where V is the number of vertices.</p>
                <p><strong>Computational Thinking:</strong></p>
                <ul>
                    <li><strong>Decomposition:</strong> Break the problem into finding the shortest path from one vertex to another.</li>
                    <li><strong>Pattern Recognition:</strong> Recognize the problem of finding minimum distance at each step.</li>
                    <li><strong>Abstraction:</strong> Ignore the individual steps of iteration and focus on the result.</li>
                </ul>
                <p><strong>Design Techniques:</strong></p>
                <ul>
                    <li><strong>Greedy Approach:</strong> Select the next closest node to the source vertex.</li>
                    <li><strong>Recursive Thinking:</strong> Dijkstra's algorithm is naturally recursive in its approach to finding the shortest paths.</li>
                </ul>
                <p><strong>Principles:</strong></p>
                <ul>
                    <li><strong>Optimal Substructure:</strong> The shortest path to any node is the combination of the shortest paths to its neighboring nodes.</li>
                    <li><strong>Overlapping Subproblems:</strong> The problem of finding the shortest path is solved repeatedly for each vertex.</li>
                </ul>
            </div>

            <!-- Code for Dijkstra's Algorithm -->
            <button class="accordion">View Dijkstra's Algorithm Code</button>
            <div class="panel">
                <pre><code>#include&lt;iostream&gt;
using namespace std;

class Dijkstra
{
public:
    int cost[10][10];
    int vertices;
    int dist[10];
    int path[10];
    bool visited[10];

    void read_cost();
    void initialise(int source);
    void shortest_path(int source);
    void print_path();
};

void Dijkstra::read_cost()
{
    cout &lt;&lt; "Enter the cost matrix: " &lt;&lt; endl;
    for (int i = 0; i &lt; vertices; i++)
    {
        for (int j = 0; j &lt; vertices; j++)
        {
            cin &gt;&gt; cost[i][j];
        }
    }
}

void Dijkstra::initialise(int source)
{
    for (int i = 0; i &lt; vertices; i++)
    {
        dist[i] = 1000000;
        visited[i] = false;
        path[i] = -1;
    }
    dist[source] = 0;
}

void Dijkstra::shortest_path(int source)
{
    for (int i = 0; i &lt; vertices - 1; i++)
    {
        int min_dist = 1000000;
        int u;

        for (int v = 0; v &lt; vertices; v++)
        {
            if (!visited[v] && dist[v] &lt; min_dist)
            {
                min_dist = dist[v];
                u = v;
            }
        }

        visited[u] = true;

        for (int v = 0; v &lt; vertices; v++)
        {
            if (!visited[v] && cost[u][v] != -1 && dist[u] + cost[u][v] &lt; dist[v])
            {
                dist[v] = dist[u] + cost[u][v];
                path[v] = u;
            }
        }
    }
}

void Dijkstra::print_path()
{
    cout &lt;&lt; "Energy distribution paths: " &lt;&lt; endl;
    for (int i = 0; i &lt; vertices; i++)
    {
        cout &lt;&lt; "Sector " &lt;&lt; i &lt;&lt; ": Distance = " &lt;&lt; dist[i] &lt;&lt; ", Path: ";
        int vertex = i;
        while (vertex != -1)
        {
            cout &lt;&lt; vertex &lt;&lt; " ";
            vertex = path[vertex];
        }
        cout &lt;&lt; endl;
    }
}

int main()
{
    Dijkstra d;
    cout &lt;&lt; "Enter number of sectors: ";
    cin &gt;&gt; d.vertices;
    d.read_cost();

    int source;
    cout &lt;&lt; "Enter the source sector: ";
    cin &gt;&gt; source;

    d.initialise(source);
    d.shortest_path(source);
    d.print_path();

    return 0;
}
                </code></pre>
            </div>
        </section>
    </div>
    
    <script src="script.js"></script>
</body>
</html>
