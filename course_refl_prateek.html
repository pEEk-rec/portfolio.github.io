<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Design and Analysis of Algorithms Learning Portfolio</title>
    <style>
        body {
            font-family: 'Georgia', serif;
            margin: 0;
            padding: 0;
            background-color: #ffffff;
            color: #2e7d32;
        }

        header {
            background-color: #a5d6a7;
            color: #1b5e20;
            text-align: center;
            padding: 20px;
        }

        header h1 {
            font-size: 2.8em;
            margin: 0;
        }

        .container {
            max-width: 1200px;
            margin: auto;
            padding: 20px;
        }

        section {
            margin-bottom: 50px;
        }

        h2 {
            font-size: 2em;
            color: #2e7d32;
            margin-bottom: 20px;
        }

        h3 {
            font-size: 1.5em;
            margin-top: 30px;
            color: #388e3c;
        }

        p {
            line-height: 1.8;
            font-size: 1.1em;
        }

        footer {
            text-align: center;
            padding: 20px;
            background-color: #1b5e20;
            color: white;
        }

        footer a {
            color: #c8e6c9;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>

<header>
    <h1>Design and Analysis of Algorithms Learning Portfolio</h1>
</header>

<div class="container">
    <section>
        <h2>Introduction</h2>
        <p>
            The "Design and Analysis of Algorithms" course explores the foundations of computational problem-solving. It emphasizes the principles and techniques used to design algorithms that are efficient, reliable, and adaptable to a wide range of problems.
        </p>
        <p>
            In this course, we studied various data structures such as arrays, linked lists, stacks, queues, trees, heaps, and graphs, along with algorithms like sorting, searching, graph traversal, and shortest path. The focus was on understanding their practical applications, strengths, and trade-offs.
        </p>
        <p>
            Connecting the course with real-world applications has been a significant highlight. For instance, algorithms like Dijkstra’s are crucial in transportation networks for finding optimal routes, while tree structures are widely used in databases and hierarchical file systems. Sorting and searching algorithms find their use in e-commerce platforms to display search results efficiently.
        </p>
    </section>

    <section>
        <h2>Course Learning Reflections</h2>

        <h3>Natural Problems: Iteration, Recursion, and Backtracking</h3>
        <p>
            Many real-world problems can be broken into smaller components. For instance, recursion simplifies tasks like tree traversal, while backtracking is vital in constraint satisfaction problems such as solving puzzles or route planning.
        </p>

        <h3>Efficiency of Problem-Solving Techniques</h3>
        <p>
            The efficiency of an algorithm can be measured by two factors:
        </p>
        <ul>
            <li><strong>Time Efficiency:</strong> How much time an algorithm takes relative to the input size.</li>
            <li><strong>Space Efficiency:</strong> How much memory an algorithm uses during execution.</li>
        </ul>
        <p>
            Orders of Growth help predict how an algorithm will perform as input size increases, guiding developers in choosing the right algorithm for specific problem constraints.
        </p>
        <ul>
            <li><strong>Divide and Conquer:</strong> Breaking problems into smaller parts, solving each, and combining results.</li>
            <li><strong>Greedy Algorithms:</strong> Making local optimal choices to achieve global solutions.</li>
            <li><strong>Dynamic Programming:</strong> Solving overlapping subproblems to optimize solutions.</li>
        </ul>

        <h3>Hierarchical Data Structures</h3>
        <p>
            Tree structures like binary search trees (BST), AVL trees, and heaps offer efficient data organization and retrieval. Structures like tries optimize prefix-based searches, while Red-Black and 2-3 trees ensure balanced operations in databases.
        </p>

        <h3>Trees vs. Graphs</h3>
        <p>
            Trees represent hierarchical data, making them suitable for file systems and organizational charts. Graphs, however, model interconnected systems, such as social networks and transportation networks. Their traversal algorithms like DFS and BFS provide insights into connectivity and optimization.
        </p>

        <h3>Sorting and Searching Algorithms</h3>
        <p>
            Sorting algorithms, from Quick Sort to Merge Sort, are fundamental for data organization. Searching algorithms like binary search ensure rapid access to information. These techniques are pivotal in e-commerce, data analytics, and AI.
        </p>

        <h3>Graph Algorithms</h3>
        <p>
            Graph-based techniques like Prim’s and Kruskal’s algorithms for spanning trees and Dijkstra’s for shortest paths are crucial in logistics, telecommunications, and energy distribution.
        </p>

        <h3>Algorithm Design Techniques</h3>
        <p>
            Mastering algorithm design principles, including divide and conquer, greedy, and dynamic programming, equips us to tackle diverse problem spaces, from scheduling to resource allocation.
        </p>
    </section>

    <section>
        <h2>Reflections on Problem Solving</h2>
        <p>
            <strong>Determining Efficiency:</strong> To solve a complex problem, first analyze constraints such as input size and time limits, then select an algorithm with the best time and space trade-offs. For example, Quick Sort is efficient for general sorting.
        </p>
        <p>
            <strong>Balancing Conflicting Constraints:</strong> In designing the energy grid, I had to consider cost, efficiency, and scalability. This required iterative refinements, balancing these factors to achieve a sustainable solution.
        </p>
        <p>
            <strong>Adapting Solutions:</strong> Existing algorithms like Dijkstra’s were adapted to meet dynamic grid conditions. This involved modifying edge weights based on real-time energy flow data.
        </p>
        <p>
            <strong>Breaking Down Problems:</strong> Dividing complex tasks into smaller components, such as separating energy generation from distribution optimization, made the problem manageable and solutions more effective.
        </p>
        <p>
            <strong>Trade-offs in Approaches:</strong> Choosing between simplicity and optimization was critical. Initially, simpler models helped validate concepts, while advanced optimizations were applied in later stages for enhanced performance.
        </p>
    </section>

    <section>
        <h2>Conclusion</h2>
        <p>
            The "Design and Analysis of Algorithms" course has helped build a strong foundation in problem-solving. It connected theory with practical applications, enabling logical and efficient approaches to challenges. The project highlighted how algorithms can drive innovative and sustainable solutions.
        </p>
    </section>
</div>

<footer>
    <p>&copy; 2024 Design and Analysis of Algorithms Portfolio | All Rights Reserved</p>
</footer>

</body>
</html>
